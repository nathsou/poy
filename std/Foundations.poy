
pub struct Console {
    log: _ -> (),
    warn: _ -> (),
    info: _ -> (),
    error: _ -> (),
    time: Str -> (),
    timeEnd: Str -> (),
    clear: () -> (),
}

pub declare let console: Console
pub let print = console.log

pub type {
    ReturnType<Function<_, ret>> = ret
    Parameters<Function<args, _>> = args
    ElementType<a[]> = a
}

pub declare module Math {
    fun sqrt(x: Num): Num
    fun cbrt(x: Num): Num
    fun min(a: Num, b: Num): Num
    fun max(a: Num, b: Num): Num
    fun floor(x: Num): Num
    fun ceil(x: Num): Num
    fun round(x: Num): Num
    fun abs(x: Num): Num
    fun pow(x: Num, y: Num): Num
    fun random(): Num
    fun log(x: Num): Num
    fun log2(x: Num): Num
    fun log10(x: Num): Num
    fun exp(x: Num): Num
    fun cos(x: Num): Num
    fun sin(x: Num): Num
    fun tan(x: Num): Num
    fun acos(x: Num): Num
    fun asin(x: Num): Num
    fun atan(x: Num): Num
    fun atan2(y: Num, x: Num): Num
    fun hypot(x: Num, y: Num): Num
    fun sign(x: Num): Num
}

pub extend Num {
    fun sqrt() { Math.sqrt(self) }
    fun floor() { Math.floor(self) }
    fun ceil() { Math.ceil(self) }
    fun round() { Math.round(self) }
}

pub enum Option<t> { none, some(t) }

pub extend<a> Option<a> {
    fun isSome() {
        match self {
            .some(_) => true,
            .none => false,
        }
    }

    fun isNone() {
        match self {
            .none => true,
            _ => false,
        }
    }

    fun map(f) {
        match self {
            .some(x) => .some(f(x)),
            .none => .none,
        }
    }

    fun flatMap(f) {
        match self {
            .some(x) => f(x),
            .none => .none,
        }
    }

    fun do(f: a -> ()) {
        match self {
            .some(val) => f(val),
            .none => (),
        }
    }
}

pub fun range(from: Num, to: Num) {
    mut i = from

    while i < to {
        yield i
        i += 1
    }
}

pub extend Str {
    declare {
        fun startsWith(str: Str): Bool
        fun endsWith(str: Str): Bool
        fun includes(str: Str): Bool
    }
}

pub extend Str[] {
    declare fun join(sep: Str): Str
}

pub extend<a> a[] {
    static fun init(): Self { [] }

    declare let length: Num
    declare fun at(index: Num): a
    declare fun concat(other: a[]): a[]

    #as("copyWithin")
    declare {
        fun copyWithin(target: Num, start: Num): ()
        fun copyWithinWithEnd(target: Num, start: Num, end: Num): ()
    }

    declare fun entries(): Iterator<(Num, a)>
    declare fun every(predicate: a -> Bool): Bool

    #as("fill")
    declare {
        fun fill(value: a, start: Num): ()
        fun fillWithEnd(value: a, start: Num, end: Num): ()
    }
    
    declare fun filter(predicate: a -> Bool): a[]
    declare fun find(predicate: a -> Bool): a
    declare fun findIndex(predicate: a -> Bool): Num
    declare fun findLast(predicate: a -> Bool): a
    declare fun findLastIndex(predicate: a -> Bool): Num

    #as("flat")
    declare {
        fun flat(): a[]
        fun flatWithDepth(depth: Num): a[]
    }

    declare fun flatMap<b>(f: a -> b[]): b[]
    declare fun forEach(f: a -> ()): ()
    declare fun filter(predicate: a -> Bool): a[]
    declare fun flatMap<b>(f: a -> b[]): b[]
    declare fun forEach(f: a -> ()): ()

    #as("includes")
    declare {
        fun includes(elem: a): Bool
        fun includesFromIndex(elem: a, fromIndex: Num): Bool
    }
    
    #as("indexOf")
    declare {
        fun indexOf(elem: a): Num
        fun indexOfFromIndex(elem: a, fromIndex: Num): Num
    }

    #as("lastIndexOf")
    declare {
        fun lastIndexOf(elem: a): Num
        fun lastIndexOfFromIndex(elem: a, fromIndex: Num): Num
    }

    declare fun map<b>(f: a -> b): b[]
    declare fun pop(): a
    declare fun push(elem: a): ()
    declare fun reduce<b>(f: (b, a) -> b, init: b): b
    declare fun reduceRight<b>(f: (b, a) -> b, init: b): b

    #as("reverse")
    declare fun reverseInPlace(): ()

    #as("toReversed")
    declare fun reversed(): a[]

    declare fun shift(): a

    #as("slice")
    declare {
        fun slice(start: Num): a[]
        fun sliceWithEnd(start: Num, end: Num): a[]
    }

    declare fun some(predicate: a -> Bool): Bool

    #as("sort")
    declare fun sortInPlace(): ()

    #as("toSorted")
    declare fun sorted(): a[]
    
    #as("splice")
    declare {
        fun splice(start: Num): a[]
        fun spliceWithDeleteCount(start: Num, deleteCount: Num): a[]
    }

    #as("toSpliced")
    declare {
        fun spliced(start: Num): a[]
        fun splicedWithDeleteCount(start: Num, deleteCount: Num): a[]
    }

    declare fun unshift(elem: a): Num
    declare fun values(): Iterator<a>
    declare fun with(index: Num, value: a): a[]
 
    #as("Symbol.iterator")
    declare fun iter(): Iterator<a>

    #as("at")
    declare fun `[]`(index: Num): a

    fun first() { self[0] }

    fun lastIndex(): Num { self.length - 1 }

    fun last() { self[self.length - 1] }

    fun isEmpty(): Bool {
        self.length == 0
    }

    fun count(predicate: a -> Bool): Num {
        mut count = 0
        mut i = 0

        while i < self.length {
            if predicate(self[i]) {
                count += 1
            }

            i += 1
        }

        count
    }

    fun zip<b>(other: b[]): (a, b)[] {
        let len = Math.min(self.length, other.length)
        mut res = []
        mut i = 0

        while i < len {
            res.push((self[i], other[i]))
            i += 1
        }

        res
    }

    fun join(formatFn: a -> Str, separator): Str {
        self.map(formatFn).join(separator)
    }
}

pub extend Num[] {
    fun sum() {
        mut total = 0
        mut i = 0

        while i < self.length {
            total += self[i]
            i += 1
        }

        total
    }

    fun product() {
        mut total = 1
        mut i = 0

        while i < self.length {
            total *= self[i]
            i += 1
        }

        total 
    }
}

pub extend<a> Iterator<a> {
    fun map(f) {
        for v in self {
            yield f(v)
        }
    }

    fun filter(pred) {
        for v in self {
            if pred(v) {
                yield v
            }
        }
    }

    fun sum() {
        mut total = 0

        for v in self {
            total += v
        }

        total
    }

    fun product() {
        mut res = 1

        for v in self {
            res *= v
        }

        res
    }

    fun toArray() {
        mut res = []

        for v in self {
            res.push(v)
        }

        res
    }

    fun findIndex(pred: a -> Bool) {
        mut i = 0

        for v in self {
            if pred(v) {
                return i
            }

            i += 1
        }

        -1
    }
}

#new("Map")
declare fun initMap(): Map<_, _>

#new("Map")
declare fun initMapFromEntries<k, v>(entries: Iterator<(k, v)>): Map<k, v>

pub extend Map {
    static fun init() {
        initMap()
    }
}

pub extend<k, v> Map<k, v> {
    declare {
        let size: Num
        fun clear(): ()
        fun delete(key: k): ()
        fun entries(): Iterator<(k, v)>
        fun forEach(f: (v, k) -> ()): ()
        fun get(key: k): v
        fun has(key: k): Bool
        fun keys(): Iterator<k>
        fun set(key: k, value: v): ()
        fun values(): Iterator<v>
    }

    static fun init(): Self {
        initMap()
    }

    static fun fromEntries(entries) {
        initMapFromEntries(entries)
    }

    fun map<k2, v2>(f: (k, v) -> (k2, v2)): Map<k2, v2> {
        initMapFromEntries(self.entries().map(kv -> f(kv.0, kv.1)))
    }

    fun mapKeys<k2>(f: (k, v) -> k2): Map<k2, v> {
        initMapFromEntries(self.entries().map(kv -> {
            let k = kv.0
            let v = kv.1
            let k2 = f(k, v)

            (k2, v)
        }))
    }

    fun mapValues<v2>(f: (k, v) -> v2): Map<k, v2> {
        initMapFromEntries(self.entries().map(kv -> {
            let k = kv.0
            let v = kv.1
            let v2 = f(k, v)

            (k, v2)
        }))
    }

    fun groupBy<k2>(f: v -> k2): Map<k2, v[]> {
        mut grouped = initMap()

        for pair in self.entries() {
            let key = pair.0
            let val = pair.1
            let k = f(key)

            if grouped.has(k) {
                grouped.get(k).push(val)
            } else {
                grouped.set(k, [val])
            }
        }

        grouped
    }
}

pub extend <k, e> Map<k, e[]> {
    fun push(key, elem) {
        if self.has(key) {
            self.get(key).push(elem)
        } else {
            self.set(key, [elem])
        }
    }
}

pub extend Set<a> {
    declare {
        let size: Num
        fun add(value: a): ()
        fun clear(): ()
        fun delete(value: a): ()
        fun difference(other: Set<a>): Set<a>
        fun entries(): Iterator<(a, a)>
        fun forEach(f: a -> ()): ()
        fun has(value: a): Bool
        fun intersection(other: Set<a>): Set<a>
        fun isDisjointFrom(other: Set<a>): Bool
        fun isSubsetOf(other: Set<a>): Bool
        fun isSupersetOf(other: Set<a>): Bool
        fun keys(): Iterator<a>
        fun symmetricDifference(other: Set<a>): Set<a>
        fun union(other: Set<a>): Set<a>
        fun values(): Iterator<a>
    }
}

pub enum Type {
    variable(Str),
    compound(Str, Type[]),
}

pub extend Type {
    fun show(): Str {
        match self {
            .variable(name) => name,
            .compound("Array", args) => args.first().show() ++ "[]",
            .compound(name, args) => {
                if args.length == 0 {
                    name
                } else {
                    "\(name)<\(args.map(arg -> arg.show()).join(", "))>"
                }
            }
        }
    }

    fun isArray(): Bool {
        match self {
            .compound("Array", _) => true,
            _ => false,
        }
    }

    fun elementType(): Option<Type> {
        match self {
            .compound("Array", args) => .some(args.first()),
            _ => .none,
        }
    }

    fun isTuple(): Bool {
        match self {
            .compound("Tuple", _) => true,
            _ => false,
        }
    }
}

pub declare let typeOf: _ -> Type
