
pub struct Console {
    log: _ -> (),
    warn: _ -> (),
    info: _ -> (),
    error: _ -> (),
    time: Str -> (),
    timeEnd: Str -> (),
    clear: () -> (),
}

pub declare let console: Console
pub let print = console.log

pub type {
    ReturnType<Function<_, ret>> = ret
    Parameters<Function<args, _>> = args
    ElementType<a[]> = a
}

pub declare module Math {
    fun sqrt(x: Num): Num
    fun cbrt(x: Num): Num
    fun min(a: Num, b: Num): Num
    fun max(a: Num, b: Num): Num
    fun floor(x: Num): Num
    fun ceil(x: Num): Num
    fun round(x: Num): Num
    fun abs(x: Num): Num
    fun pow(x: Num, y: Num): Num
    fun random(): Num
    fun log(x: Num): Num
    fun log2(x: Num): Num
    fun log10(x: Num): Num
    fun exp(x: Num): Num
    fun cos(x: Num): Num
    fun sin(x: Num): Num
    fun tan(x: Num): Num
    fun acos(x: Num): Num
    fun asin(x: Num): Num
    fun atan(x: Num): Num
    fun atan2(y: Num, x: Num): Num
    fun hypot(x: Num, y: Num): Num
    fun sign(x: Num): Num
}

extend Num {
    fun sqrt() { Math.sqrt(self) }
    fun floor() { Math.floor(self) }
    fun ceil() { Math.ceil(self) }
    fun round() { Math.round(self) }
}

pub enum Option<t> { none, some(t) }

extend<a> Option<a> {
    fun isSome() {
        match self {
            .some(_) => true,
            .none => false,
        }
    }

    fun isNone() {
        match self {
            .none => true,
            _ => false,
        }
    }

    fun map(f) {
        match self {
            .some(x) => .some(f(x)),
            .none => .none,
        }
    }

    fun flatMap(f) {
        match self {
            .some(x) => f(x),
            .none => .none,
        }
    }

    fun do(f: a -> ()) {
        match self {
            .some(val) => f(val),
            .none => (),
        }
    }
}

pub fun range(from: Num, to: Num) {
    mut i = from

    while i < to {
        yield i
        i += 1
    }
}

extend Str {
    declare {
        fun startsWith(str: Str): Bool
        fun endsWith(str: Str): Bool
        fun includes(str: Str): Bool
    }
}

extend Str[] {
    declare fun join(sep: Str): Str
}

extend<a> a[] {
    static fun init(): Self { [] }
   
    declare {
        let length: Num
        fun at(index: Num): a
        fun push(elem: a): ()
        fun pop(): a
        fun filter(predicate: a -> Bool): a[]
        fun map<b>(f: a -> b): b[]
        fun flatMap<b>(f: a -> b[]): b[]
        fun find(predicate: a -> Bool): a
        fun findIndex(predicate: a -> Bool): Num
        fun forEach(f: a -> ()): ()
        fun slice(start: Num, end: Num): a[]
        fun includes(value: a): Bool
        fun some(predicate: a -> Bool): Bool
        fun every(predicate: a -> Bool): Bool
    }

    #as("Symbol.iterator")
    declare fun iter(): Iterator<a>

    #as("at")
    declare fun `[]`(index: Num): a

    fun first() { self[0] }

    fun lastIndex(): Num { self.length - 1 }

    fun last() { self[self.length - 1] }

    fun reversed() {
        mut rev = []
        mut i = self.lastIndex()

        while i >= 0 {
            rev.push(self[i])
            i -= 1
        }

        rev
    }

    fun isEmpty(): Bool {
        self.length == 0
    }

    fun count(predicate: a -> Bool): Num {
        mut count = 0
        mut i = 0

        while i < self.length {
            if predicate(self[i]) {
                count += 1
            }

            i += 1
        }

        count
    }

    fun zip<b>(other: b[]): (a, b)[] {
        let len = Math.min(self.length, other.length)
        mut res = []
        mut i = 0

        while i < len {
            res.push((self[i], other[i]))
            i += 1
        }

        res
    }

    fun join(formatFn: a -> Str, separator): Str {
        self.map(formatFn).join(separator)
    }
}

extend Num[] {
    fun sum() {
        mut total = 0
        mut i = 0

        while i < self.length {
            total += self[i]
            i += 1
        }

        total
    }

    fun product() {
        mut total = 1
        mut i = 0

        while i < self.length {
            total *= self[i]
            i += 1
        }

        total 
    }
}

pub enum Type {
    variable(Str),
    compound(Str, Type[]),
}

extend Type {
    pub fun show(): Str {
        match self {
            .variable(name) => name,
            .compound("Array", args) => args.first().show() ++ "[]",
            .compound(name, args) => {
                if args.length == 0 {
                    name
                } else {
                    "\(name)<\(args.map(arg -> arg.show()).join(", "))>"
                }
            }
        }
    }

    pub fun isArray(): Bool {
        match self {
            .compound("Array", _) => true,
            _ => false,
        }
    }

    pub fun elementType(): Option<Type> {
        match self {
            .compound("Array", args) => .some(args.first()),
            _ => .none,
        }
    }

    pub fun isTuple(): Bool {
        match self {
            .compound("Tuple", _) => true,
            _ => false,
        }
    }
}

pub declare let typeOf: _ -> Type
